""" 
Не рекурсивный прямой обход бинарного дерева — это метод обхода, при котором узлы дерева посещаются в определенном порядке, 
не используя рекурсию. В прямом обходе порядок посещения узлов следующий: 
1. Сначала посещается корень (текущий узел). 
2. Затем выполняется обход левого поддерева. 
3. После этого выполняется обход правого поддерева. 
"""

# Класс, представляющий узел бинарного дерева
class TreeNode:

    def __init__(self, value):
        # Инициализация нового узла с переданным значением
        self.value = value
        # Инициализация левого потомка как None
        self.left = None
        # Инициализация правого потомка как None
        self.right = None

# Функция для построения бинарного дерева из линейно-скобочной записи
def build_tree(s):

    # Инициализация пустого стека для хранения узлов дерева
    stack = []
    # Установка начального индекса для прохода по строке
    index = 0
    # Получение длины строки
    n = len(s)

    # Цикл, проходящий по всей строке
    while index < n:
        # Получение текущего символа строки
        char = s[index]

        # Если текущий символ - цифра
        if char.isdigit():
            # Начало числа (цифры) в строке
            start = index
            # Прохождение по цифрам до тех пор, пока они встречаются подряд
            while index < n and s[index].isdigit():
                index += 1
            # Преобразование подстроки цифр в целое число
            value = int(s[start:index])
            # Создание нового узла с этим числом
            node = TreeNode(value)
            # Помещение узла в стек
            stack.append(node)

        # Если текущий символ - открывающаяся скобка
        elif char == '(':
            # Переход к следующему символу
            index += 1
            # Пропуск текущей итерации цикла
            continue

        # Если текущий символ - запятая
        elif char == ',':
            # Переход к следующему символу
            index += 1
            # Пропуск текущей итерации цикла
            continue

        # Если текущий символ - закрывающаяся скобка
        elif char == ')':
            # Переход к следующему символу
            index += 1
            # Извлечение правого потомка из стека (если есть)
            right = stack.pop() if stack else None
            # Извлечение левого потомка из стека (если есть)
            left = stack.pop() if stack else None
            # Извлечение родителя из стека (если есть)
            node = stack.pop() if stack else None
            # Присваивание левого и правого потомков родителю
            if node:
                node.left = left
                node.right = right
                # Помещение обновленного узла обратно в стек
                stack.append(node)
            # Пропуск текущей итерации цикла
            continue

        # Переход к следующему символу
        index += 1

    # Возвращение корня дерева (первого элемента стека) или None, если стек пуст
    return stack[0] if stack else None

# Функция для выполнения прямого обхода бинарного дерева.
def iterative_pre_order(node):

    # Проверка на наличие узла
    if not node:
        return

    # Инициализация стека с корнем дерева
    stack = [node]
    # Инициализация списка для результата
    result = []

    # Пока стек не пуст
    while stack:
        # Извлечение последнего узла из стека
        current = stack.pop()
        # Добавление значения узла в результат
        result.append(current.value)

        # Если у узла есть правый потомок, добавляем его в стек
        if current.right:
            stack.append(current.right)
        # Если у узла есть левый потомок, добавляем его в стек
        if current.left:
            stack.append(current.left)

    # Вывод результатов в одну строку через пробелы
    print(" ".join(map(str, result)))


if __name__ == "__main__":
    input_string = input("Введите линейно-скобочную запись для построения бинарного дерева: ")
    # Строим дерево из введенной строки
    tree_root = build_tree(input_string)
    # Выполняем прямой обхода дерева и выводим результаты
    iterative_pre_order(tree_root)
    
"""
8(3(1,6(4,7)),10(,14(13,)))
"""
