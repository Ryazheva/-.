def calculate(expression):
    try:
        # Вызываем функцию для оценки выражения
        result = evaluate_expression(expression)
        # Формируем строку с результатом, округляя до 6 значащих цифр
        return f"{result:.6g}"
    except ZeroDivisionError as e:
        # проверяем наличие деления на ноль
        return "Ошибка. Деление на ноль."
    except SyntaxError as e:
        # проверяем на синтаксические ошибки
        return "Ошибка синтаксиса."
    except ValueError as e:
        # проверяем на ошибки неправильного формата данных
        return "Неверная операция или символ."
    except Exception as e:
        # проверяем на любые другие возможные исключения
        return f"Произошла ошибка: {e}"

# функция для вычисления значения выражения
def evaluate_expression(expression):
    # Проверяем, содержит ли строка знак '=', который указывает на конец выражения
    if '=' not in expression:
        # Если знак '=' отсутствует, генерируем ошибку
        raise SyntaxError("Отсутствует знак '='")

    # Удаляем лишние пробелы и символы новой строки в начале и конце строки
    expression = expression.strip()
    # Удаляем все пробелы внутри строки
    expression = expression.replace(' ', '')
    # Удаляем последний символ ('=')
    expression = expression[:-1]

    # Проверяем, правильно ли расставлены скобки в выражении
    if not is_balanced_parentheses(expression):
        # Если скобки расставлены неправильно, генерируем ошибку
        raise SyntaxError("Некорректная расстановка скобок.")

    # Разбиваем строку на токены (числа и операторы)
    tokens = tokenize(expression)
    # Преобразуем инфиксную запись в постфиксную
    postfix = infix_to_postfix(tokens)
    # Вычисляем значение выражения в постфиксной форме
    return evaluate_postfix(postfix)

# Функция для разбиения выражения на токены
def tokenize(expression):
    # Создаем пустой список для хранения токенов
    tokens = []
    # Переменная для временного хранения текущего токена
    current_token = ""
    # Проходим по каждому символу в строке
    for char in expression:
        # Если текущий символ является цифрой или точкой (часть числа), добавляем его к текущему токену
        if char.isdigit() or char == '.':
            current_token += char
        else:
            # Если текущий токен уже заполнен, добавляем его в список токенов
            if current_token:
                tokens.append(current_token)
            # Сбрасываем текущий токен
            current_token = ""

            # Если текущий символ не пробел, добавляем его в список токенов
            if char != ' ':
                tokens.append(char)

    # Если остался незакрытый токен, добавляем его в список токенов
    if current_token:
        tokens.append(current_token)

    # Возвращаем список токенов
    return tokens

# Функция для преобразования инфиксного выражения в постфиксное
def infix_to_postfix(tokens):
    # Создаем пустой список для хранения результата преобразования
    output = []
    # Стек для операторов
    stack = []
    # Словарь приоритетов операторов
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}

    # Проходим по каждому токену
    for token in tokens:
        # Если токен является числом, добавляем его в выходной список
        if token.replace('.', '', 1).isdigit():
            output.append(token)
        # Если токен - открывающая скобка, кладем ее в стек
        elif token == '(':
            stack.append(token)
        # Если токен - закрывающая скобка, извлекаем все операторы до ближайшей открывающей скобки
        elif token == ')':
            while stack and stack[-1] != '(':
                output.append(stack.pop())
            # Извлекаем открывающую скобку из стека
            stack.pop()
        else:
            # Пока стек не пуст и приоритет текущего оператора меньше или равен приоритету верхнего элемента стека,
            # извлекаем элементы из стека и добавляем их в выходной список
            while stack and stack[-1] != '(' and precedence.get(token, 0) <= precedence.get(stack[-1], 0):
                output.append(stack.pop())
            # Кладем оператор в стек
            stack.append(token)

    # Добавляем оставшиеся операторы из стека в выходной список
    while stack:
        output.append(stack.pop())

    # Возвращаем преобразованное выражение
    return output

# Функция для вычисления значения выражения в постфиксной форме
def evaluate_postfix(tokens):
    # Создаём пустой стек для хранения промежуточных значений
    stack = []

    # Проходим по каждому токену в списке
    for token in tokens:
        # Если токен представляет собой число...
        if token.replace('.', '', 1).isdigit():
            # Преобразуем его в вещественное число и добавляем в стек
            stack.append(float(token))
        else:
            # Извлекаем два верхних элемента из стека (это наши операнды)
            operand2 = stack.pop()
            operand1 = stack.pop()

            # В зависимости от типа операции выполняем соответствующее действие
            if token == '+':
                # Складываем два операнда и сохраняем результат обратно в стек
                stack.append(operand1 + operand2)
            elif token == '-':
                # Вычитаем второй операнд из первого и сохраняем результат в стек
                stack.append(operand1 - operand2)
            elif token == '*':
                # Умножаем два операнда и сохраняем результат в стек
                stack.append(operand1 * operand2)
            elif token == '/':
                # Проверяем, не пытаемся ли мы делить на ноль
                if operand2 == 0:
                    # Если да, поднимаем исключение
                    raise ZeroDivisionError("Деление на ноль!")
                # Делим первый операнд на второй и сохраняем результат в стек
                stack.append(operand1 / operand2)

    # После завершения цикла возвращаем единственный оставшийся элемент стека – итоговый результат
    return stack.pop()

# Функция для проверки корректности расстановки скобок
def is_balanced_parentheses(expression):
    # Создаём пустой стек для отслеживания пар скобок
    stack = []
    # Проходим по каждому символу в выражении
    for char in expression:
        # Если находим открывающую скобку, добавляем её в стек
        if char == '(':
            stack.append(char)
        # Если находим закрывающую скобку...
        elif char == ')':
            # ...проверяем, есть ли соответствующая открывающая скобка в стеке
            if not stack or stack.pop() != '(':
                # Если стек пуст или верхний элемент не соответствует открывающей скобке, возвращаем False
                return False
    # Если стек пуст после прохождения всех символов, значит скобки сбалансированы
    return not stack

# Запрашиваем у пользователя ввод выражения
expression = input("Введите выражение: ")
# Выводим результат вычисления выражения
print(calculate(expression))
